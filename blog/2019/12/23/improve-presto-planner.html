<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Improving the Presto planner for better push down and data federation · </title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="**Alibaba:** Yuan Mei"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Improving the Presto planner for better push down and data federation · "/><meta property="og:type" content="website"/><meta property="og:url" content="https://yhwang.github.io/prestodb.github.io//blog/2019/12/23/improve-presto-planner"/><meta property="og:description" content="**Alibaba:** Yuan Mei"/><meta property="og:image" content="https://yhwang.github.io/prestodb.github.io/img/presto-logo-stacked.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://yhwang.github.io/prestodb.github.io/img/presto-logo-stacked.png"/><link rel="shortcut icon" href="/img/icon-presto-dots-color.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="/css/bootstrap.min.css"/><link rel="stylesheet" href="/css/custom.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://js.hs-scripts.com/39785153.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo-presto-white.svg" alt=""/><h2 class="headerTitleWithLogo"></h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/getting-started.html" target="_self">Get Started</a></li><li class=""><a href="/what-is-presto.html" target="_self">Learn</a></li><li class=""><a href="/community.html" target="_self">Community</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><li class=""><a href="/docs/current" target="_blank">Docs</a></li><li class=""><a href="https://communityinviter.com/apps/prestodb/prestodb" target="_blank">Slack</a></li><li class=""><a href="https://github.com/prestodb/presto" target="_blank">GitHub</a></li><li class=""><a href="https://stackoverflow.com/questions/tagged/presto" target="_blank">Stackoverflow</a></li><li class=""><a href="https://twitter.com/prestodb" target="_blank">Twitter</a></li><li class=""><a href="https://www.linkedin.com/company/presto-foundation/" target="_blank">LinkedIn</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/blog/2023/08/29/presto-working-groups">Introducing Presto Working Groups</a></li><li class="navListItem"><a class="navItem" href="/blog/2023/08/17/scaling-presto-panel-blog">Scaling Presto for Data Analytics - Insights from Meta, Uber, and Intuit</a></li><li class="navListItem"><a class="navItem" href="/blog/2023/08/02/presto-on-kubernetes-with-helm-prestocon-day">Simplifying Presto on Kubernetes - Introducing the Presto Helm Chart</a></li><li class="navListItem"><a class="navItem" href="/blog/2023/07/20/quick-stats-presto-blog">Quick Stats - Runtime ANALYZE for Better Query Plans with Presto</a></li><li class="navListItem"><a class="navItem" href="/blog/2023/07/13/presto-at-bolt">Migrating to Presto - How Bolt Built a Data Platform Architecture for Scalability and Cost Efficiency</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/12/23/improve-presto-planner">Improving the Presto planner for better push down and data federation</a></h1><p class="post-meta">December 23, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="https://www.linkedin.com/in/yi-he-69aa9723/" target="_blank" rel="noreferrer noopener">Yi He</a></p></div></header><div><span><p><strong>Alibaba:</strong> Yuan Mei</p>
<p><strong>Facebook:</strong> James Sun, Maria Basmanova, Rongrong Zhong, Jiexi Lin, Saksham Sachdev</p>
<p><strong>Pinterest:</strong> Yi He</p>
<p><strong>University of Waterloo:</strong> Akshay Pall</p>
<p>Presto defines a connector API that allows Presto to query any data source that has a connector implementation. The existing connector API provides basic predicate pushdown functionality allowing connectors to perform filtering at the underlying data source.</p>
<p>However, there are certain limitations with the existing predicate pushdown functionality that limits what connectors can do. The expressiveness of what can be pushed down is limited and the connectors can't change the structure of the plan at all.</p>
<!-- truncate -->
<p>This image shows what the planner and connector interaction used to look like:
<img src="/img/blog/2019-12-19-improve-presto-planner/image_01.png" alt="Remote Exchange"></p>
<p>First, Presto only supports predicate push down through connector provided methods. If Presto needs to push down a set of operations (for example, <code>projection</code>/<code>filter</code>/<code>aggregation</code>/<code>limit</code>), then the connectors need to support several methods:</p>
<pre><code class="hljs css language-java">pushDownFilterLimitScan
pushDownProjectFilterScan
...
</code></pre>
<p>This increases the complexity of creating and maintaining a connectors. Also, as we will show later, we not only want to push down operations, but also add new operations into a query plan. The current planner model does support many useful connector driven plan changes.</p>
<p>Second, the range of predicates and operators that can be pushed down is limited. Only predicates that can be represented by a data structure called TupleDomain, can be pushed down. This data structure only supports ANDed predicates that determine whether a variable/column is in a value set (ranged or equitable). There is thus no way to describe complex predicates like <code>'A[1] IN (1, 2, 3)'</code> or <code>‘A like 'A Varchar %'’</code>.</p>
<p>A more flexible approach would be to push down the entire expression which is currently represented as an Abstract Syntax Tree (AST). One problem with this approach is that the AST evolves over time such as when new language features are added. Additionally the AST does not contain type information as well as enough information to perform function resolution.</p>
<p>Functions can now resolve to different implementations thanks to the recently added dynamic function registration. Dynamic function registration allows users to write their own SQL functions. For example, a user can update the definition of a SQL function in another session while queries using the function are still running. If we were to perform function resolution at invocation time then we could end up using different implementations within the same session and query. If we are going to support materialized views, we also need to make sure the function version is consistent between the data reader and writer.</p>
<p>We resolve this by storing function resolution information in the expression representation itself as a serializable <code>functionHandle</code>. This makes it possible to consistently reference a function when we reuse the expressions containing the function.</p>
<p>Types present a similar issue. Connectors can’t safely rely on metadata to know the type of a variable. The metadata describing the variable might be unavailable or have changed during execution.</p>
<p>We have gradually improved the Presto planner’s ability to push down more expressive operations between version 0.217 and 0.229. We also made corresponding updates to connectors allowing them to understand and operate on plan sub-trees.</p>
<h2><a class="anchor" aria-hidden="true" id="exposing-plan-sub-trees-to-connector"></a><a href="#exposing-plan-sub-trees-to-connector" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exposing plan sub-trees to connector</h2>
<p>Presto executes a SQL query by first parsing it to an Abstract Syntax Tree (AST). The AST is then converted to logical plan tree, which represents the relational algebra contained in the query. The relational algebra representation is not optimized and lacks sufficient physical layout information for query execution.</p>
<p>Presto uses a list of optimizers to transform the logical plan to an optimized physical plan. Each plan optimizer can operate on sub-trees of the whole plan tree and replace them with more optimized sub-trees based on heuristic or statistics. Optimizers can save the physical information of execution on a set of connector provided handles (for example, <code>ConnectorTableHandle</code>, <code>ConnectorTableLayoutHandle</code>, <code>ConnectorPartitionHandle</code>, …).</p>
<p><img src="/img/blog/2019-12-19-improve-presto-planner/image_02.png" alt="Remote Exchange"></p>
<p>Unlike some other SQL engines, Presto does not explicitly set the boundary between the logical plan and physical plan. Instead, there are a few crucial optimizers that transform the logical plan into a physical one.</p>
<p><code>PickTableLayout</code> and <code>AddExchanges</code> are two of the more important optimizers.</p>
<p><code>PickTableLayout</code> plans predicate push down into a table scan by calling the connector provided API method <code>getTableLayout</code>. It is also used to obtain physical layout information from the connector. <code>getTableLayout</code> returns a <code>LayoutHandle</code> that the connector populates with information on the structure of the data that will be returned by the scan. Presto will later use the <code>LayoutHandle</code> to plan, optimize, and execute the query.</p>
<p><code>AddExchanges</code> adds the data shuffling (data exchange) operators to a query execution. This important step determines how query execution is parallelized, and how data is redistributed for processing at each stage of a query. A stage of execution in Presto is generally the shuffling of data on the partition key that is required for processing the next part of a query plan. <code>AddExchanges</code> relies on the Handle returned from the connector to decide on the appropriate places and kinds of exchanges to add to the plan.</p>
<p>Relying on <code>PickTableLayout</code> to do both predicate push down and physical planning is very restrictive because there is no way for connectors to modify the plan beyond basic predicate pushdown.</p>
<p>Presto now allows connectors to provide optimization rules to the Presto engine, which allows connectors to introduce arbitrary optimizations. There are restrictions to prevent connector provided optimizers from accidentally changing another connector’s sub plan:</p>
<ol>
<li>PlanNodes that are exposed to presto-spi module.</li>
<li>PlanNodes that belong to the connector.</li>
</ol>
<p>A sub max tree that satisfies the above rules will be transformed to more optimized form picked by a connector provided optimization rule:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span>  <span class="hljs-class"><span class="hljs-keyword">interface</span>  <span class="hljs-title">ConnectorPlanOptimizer</span>
</span>{
    <span class="hljs-function">PlanNode <span class="hljs-title">optimize</span><span class="hljs-params">(
        PlanNode maxSubplan,
        ConnectorSession session,
        VariableAllocator variableAllocator,
        PlanNodeIdAllocator idAllocator)</span></span>;
}
</code></pre>
<p><img src="/img/blog/2019-12-19-improve-presto-planner/image_03.png" alt="Remote Exchange"></p>
<p>Note that, the above rule only applies to the <code>maxSubPlan</code> optimizer taken as input. It is quite possible a connector provided optimizer can generate a new plan contains nodes belonging to another connector (usually during a view expansion). In such cases, <code>TableScan</code> might be reading from a virtual table combining data from multiple different data sources. The <code>TableScan</code> on the virtual table can be expanded to a new sub tree that unions TableScans from both sides. Once expanded, the optimization of newly generated plan nodes can then be handled by the connectors they belong to, so that most optimized subplan can be achieved.</p>
<p>The connector rule will transform the sub max plan tree. In the case of predicate pushdown (taking <code>MySQLConnector</code> as an example), the connector can save the predicates that MySQL can handle as a SQL expression inside <code>MySQLConnectorLayoutHandle</code> and return a <code>TableScan</code> node.</p>
<p>The engine will apply the connector optimization rules at critical plan transformation checkpoints:</p>
<p>All rules that are operating on logical plans will be applied once before <code>AddExchange</code> to start the transformation into physical plan. At this point, we can expand views and push down many operations.</p>
<p>Some optimizations that rely on physical information need to be applied later at the end of optimization cycle. For example, we may want to only push down part of an aggregation into the connector in order to still benefit from parallel execution. Splitting up the aggregation stages happens after the exchange nodes are added.</p>
<h2><a class="anchor" aria-hidden="true" id="more-descriptive-expression-language"></a><a href="#more-descriptive-expression-language" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>More descriptive expression language</h2>
<p>We also replaced AST-based expression representation with a new representation called <code>RowExpression</code>. <code>RowExpression</code> is completely self-contained and can be shared across multiple systems. The new representation has several sub-types:</p>
<table>
<thead>
<tr><th>ExpressionType</th><th>Represents</th></tr>
</thead>
<tbody>
<tr><td><code>ConstantExpression</code></td><td>Literal values such as <code>(1L, BIGINT)</code>, <code>(&quot;string&quot;, VARCHAR)</code> ...</td></tr>
<tr><td><code>VariableReferenceExpression</code></td><td>Reference to an input column and a field of the output from previous relation expression.</td></tr>
<tr><td><code>CallExpression</code></td><td>Function calls, which includes all arithmetic operations, casts, UDFs, … with function handle resolved.</td></tr>
<tr><td><code>SpecialFormExpression</code></td><td>Special built-in function calls that is generic to any types or can only have single type(Boolean) thus function handle is not necessary. Examples are: <code>IN</code> <code>IF</code>, <code>IS_NULL</code>, <code>AND</code>,<code>OR</code>, <code>COALESCE</code>, <code>DEREFERENCE</code>, <code>ROW_CONSTRUCTOR</code>, <code>BIND</code>, ...</td></tr>
<tr><td><code>LambdaDefinitionExpression</code></td><td>Definition of anonymous (lambda) functions. For example: <code>(x:BIGINT,y:BIGINT):BIGINT -&gt; x+y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="how-are-we-using-it-so-far"></a><a href="#how-are-we-using-it-so-far" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How are we using it so far:</h2>
<h3><a class="anchor" aria-hidden="true" id="aria-scan-filter-pushdown"></a><a href="#aria-scan-filter-pushdown" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aria Scan filter pushdown</h3>
<p><a href="https://engineering.fb.com/data-infrastructure/aria-presto/">Project Aria Scan</a> aims to improve the CPU efficiency of table scan by pushing filters into the scan. The new planner provides native support for the filter pushdown required here.</p>
<h3><a class="anchor" aria-hidden="true" id="uber-pinot-connector"></a><a href="#uber-pinot-connector" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Uber Pinot connector</h3>
<p>Uber uses AresDB and Pinot to serve their real time analytics(<a href="https://www.slideshare.net/XIANGFU3/pinot-near-realtime-analytics-uber">[1]</a><a href="https://eng.uber.com/restaurant-manager/">[2]</a><a href="https://eng.uber.com/aresdb/">[3]</a>). These systems are very fast, but have limited SQL support. Presto can provide full SQL support on top of these systems to satisfy the growing need for complex analytics.</p>
<p>AresDB and Pinot can handle certain subsets of localized relational algebra. Being able to push down those operations means better efficiency and lower latency. Recently, Uber has contributed the Pinot connector to <a href="https://prestodb.io/">PrestoDB</a> which leverages the new connector architecture to push down aggregations and filters into Pinot.</p>
<p>Uber is actively working on a Presto-AresDB connector to do the same.</p>
<h3><a class="anchor" aria-hidden="true" id="scuba"></a><a href="#scuba" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scuba</h3>
<p>At Facebook, we use Scuba for analytics on real time data. The new connector architecture allows pushing down filters and aggregations into these systems to achieve better efficiency and latency.</p>
<p><a href="https://research.fb.com/publications/scuba-diving-into-data-at-facebook/">Scuba</a> is a Facebook internal system offering real time ingestion with limited retention. There are many use cases where recent data, from the last hour or day, is stored in Scuba and older data is stored in Hive. We built a Scuba connector for Presto to allow users to query data from both Hive and Scuba in the same query.</p>
<p>We also built views that combine Scuba tables with their Hive counterparts to allow for seamless querying. The support for views spanning two connectors was made possible by the new planner architecture. The connector expands the table scan node referring to the view into a union of table scans: one from Scuba, and one from Hive.</p>
<p><img src="/img/blog/2019-12-19-improve-presto-planner/image_04.png" alt="Remote Exchange"></p>
<h3><a class="anchor" aria-hidden="true" id="row-level-security"></a><a href="#row-level-security" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Row level security</h3>
<p>Sometimes we want to add filters dynamically, e.g. based on who is querying the data. For example, an employee of Coca Cola shouldn’t see records from Pepsi. We built an optimizer rule that conditionally adds Filter node on top of the TableScan node based on the query user and table structure.</p>
<p><img src="/img/blog/2019-12-19-improve-presto-planner/image_05.png" alt="Remote Exchange"></p>
<h2><a class="anchor" aria-hidden="true" id="whats-next"></a><a href="#whats-next" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What’s next?</h2>
<p>Even though the planner changes are already delivery benefits, we are still only half way there:</p>
<p>Not all optimization rules are using <code>RowExpression</code> at the moment. We are actively migrating all optimization rules to use RowExpression. In today’s version of Presto, we still rely on both connector provided optimization rules and the old API to plan for different data sources. Over time we will unify them.</p>
<p>We also want to add support for <a href="https://docs.google.com/presentation/d/10wCmZEp5NnRSb_4oPsdiKkmYy4Hy5BgddEA8brPuVis/edit#slide=id.g1fce08ab98_3_5">traits</a> to simplify the mechanism for obtaining data layout information. In the long run, we are hoping our planner can be exploratory which means we can find the lowest cost (most optimized) plan through many different optimization combinations.</p>
<p><a href="https://www.slideshare.net/XIANGFU3/pinot-near-realtime-analytics-uber">[1]</a><a href="https://www.slideshare.net/XIANGFU3/pinot-near-realtime-analytics-uber">https://www.slideshare.net/XIANGFU3/pinot-near-realtime-analytics-uber</a></p>
<p><a href="https://eng.uber.com/restaurant-manager/">[2]</a><a href="https://eng.uber.com/restaurant-manager">https://eng.uber.com/restaurant-manager</a></p>
<p><a href="https://eng.uber.com/aresdb/">[3]</a><a href="https://eng.uber.com/aresdb">https://eng.uber.com/aresdb</a></p>
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/blog/">Recent Posts</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#exposing-plan-sub-trees-to-connector">Exposing plan sub-trees to connector</a></li><li><a href="#more-descriptive-expression-language">More descriptive expression language</a></li><li><a href="#how-are-we-using-it-so-far">How are we using it so far:</a><ul class="toc-headings"><li><a href="#aria-scan-filter-pushdown">Aria Scan filter pushdown</a></li><li><a href="#uber-pinot-connector">Uber Pinot connector</a></li><li><a href="#scuba">Scuba</a></li><li><a href="#row-level-security">Row level security</a></li></ul></li><li><a href="#whats-next">What’s next?</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © The Presto Foundation.<br/>All rights reserved. Presto is a registered trademark of LF Projects, LLC. <br/>Please see our<a href="https://lfprojects.org/policies/trademark-policy/">Trademark Policy</a> for more information.<br/><a href="https://lfprojects.org/policies/privacy-policy/">Privacy Policy</a> |<a href="https://lfprojects.org/policies/terms-of-use/">Terms of Use</a>.</section></footer></div></body></html>