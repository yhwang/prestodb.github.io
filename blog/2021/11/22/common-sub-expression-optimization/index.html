<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Common Sub-Expression optimization · </title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## The problem"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Common Sub-Expression optimization · "/><meta property="og:type" content="website"/><meta property="og:url" content="https://yhwang.github.io/prestodb.github.io//blog/2021/11/22/common-sub-expression-optimization"/><meta property="og:description" content="## The problem"/><meta property="og:image" content="https://yhwang.github.io/prestodb.github.io/img/presto-logo-stacked.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://yhwang.github.io/prestodb.github.io/img/presto-logo-stacked.png"/><link rel="shortcut icon" href="/img/icon-presto-dots-color.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="/css/bootstrap.min.css"/><link rel="stylesheet" href="/css/custom.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://js.hs-scripts.com/39785153.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo-presto-white.svg" alt=""/><h2 class="headerTitleWithLogo"></h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/getting-started.html" target="_self">Get Started</a></li><li class=""><a href="/what-is-presto.html" target="_self">Learn</a></li><li class=""><a href="/community.html" target="_self">Community</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><li class=""><a href="/docs/current" target="_blank">Docs</a></li><li class=""><a href="https://communityinviter.com/apps/prestodb/prestodb" target="_blank">Slack</a></li><li class=""><a href="https://github.com/prestodb/presto" target="_blank">GitHub</a></li><li class=""><a href="https://stackoverflow.com/questions/tagged/presto" target="_blank">Stackoverflow</a></li><li class=""><a href="https://twitter.com/prestodb" target="_blank">Twitter</a></li><li class=""><a href="https://www.linkedin.com/company/presto-foundation/" target="_blank">LinkedIn</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/blog/2023/08/29/presto-working-groups">Introducing Presto Working Groups</a></li><li class="navListItem"><a class="navItem" href="/blog/2023/08/17/scaling-presto-panel-blog">Scaling Presto for Data Analytics - Insights from Meta, Uber, and Intuit</a></li><li class="navListItem"><a class="navItem" href="/blog/2023/08/02/presto-on-kubernetes-with-helm-prestocon-day">Simplifying Presto on Kubernetes - Introducing the Presto Helm Chart</a></li><li class="navListItem"><a class="navItem" href="/blog/2023/07/20/quick-stats-presto-blog">Quick Stats - Runtime ANALYZE for Better Query Plans with Presto</a></li><li class="navListItem"><a class="navItem" href="/blog/2023/07/13/presto-at-bolt">Migrating to Presto - How Bolt Built a Data Platform Architecture for Scalability and Cost Efficiency</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2021/11/22/common-sub-expression-optimization">Common Sub-Expression optimization</a></h1><p class="post-meta">November 22, 2021</p><div class="authorBlock"><p class="post-authorName"><a href="https://www.linkedin.com/in/rongrong-zhong-31aa8a8/" target="_blank" rel="noreferrer noopener">Rongrong Zhong</a></p></div></header><div><span><h2><a class="anchor" aria-hidden="true" id="the-problem"></a><a href="#the-problem" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The problem</h2>
<p>One common pattern we see in some analytical workloads is the repeated use of the same, often times expensive expression. Look at the following query plan for example:</p>
<p><img src="/img/blog/2021-11-22-common-sub-expression-optimization/query-plan.png" alt="Query Plan"></p>
<p>The expression <code>JSON_PARSE(features)</code> is used 6 times, and casted to different <code>ROW</code> structures for further processing. Traditionally, Presto would just execute the expression 6 times, in 6 separate projections. Since Presto would generate efficient bytecode for each projection, this would not be a problem as long as the expression itself is not expensive. For example, executing <code>x+y</code> 6 times in a cache efficient way would not necessarily incur a big performance overhead. However, running expensive string manipulations like <code>JSON_PARSE</code> or <code>REGEX</code> operations multiple times could quickly add up.</p>
<!--truncate-->
<h2><a class="anchor" aria-hidden="true" id="common-sub-expression-optimization"></a><a href="#common-sub-expression-optimization" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Common sub-expression optimization</h2>
<p><em>Common Sub-Expression (CSE) optimization</em> is a common optimization technique in query execution optimization. The idea is to extract the sub-expressions that are commonly used in all expressions, compute them only once, and rewrite the projections to use these results instead.</p>
<h3><a class="anchor" aria-hidden="true" id="how-does-it-work"></a><a href="#how-does-it-work" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How does it work?</h3>
<p>Let’s use projection as an example to explain how CSE optimization works. First let’s take a look at how projection worked before we introduced CSE optimization. In the query plan above, you can see that the project operator has 6 <em>assignments</em> (e.g., <code>expr := TRY_CAST(json_parse(features))</code> is one <em>assignment</em>). For each assignment in the project operator, Presto would generate a java class <code>PageProjection</code> for the projection expression. This happens on <em>presto worker</em> when worker plans local execution. The expression evaluation logic is wrapped in <code>PageProjection.project</code>, which takes in a page, and produces a block as the output. In this model, there is one <code>PageProjection</code> class generated for each assignment. Since they are separate classes, no intermediate results can be shared among different assignments.</p>
<p><img src="/img/blog/2021-11-22-common-sub-expression-optimization/page-projection.png" alt="Original PageProjection"></p>
<p>One way to allow different assignment to share intermediate result (CSE result) is to generate a single <code>PageProjection</code> class for assignments that are sharing CSEs, turning the above model to the one below:</p>
<p><img src="/img/blog/2021-11-22-common-sub-expression-optimization/new-page-projection.png" alt="New Grouped PageProjection"></p>
<p>The code that generates <code>PageProjection</code> is in <code>PageFunctionCompiler</code>. In this class, we first extract all CSEs, in the above example, there is only one CSE, which is <code>json_parse(features)</code>. We create a new assignment for the CSE, then rewrite each assignment using this newly introduced variable. So the assignments become:</p>
<pre><code class="hljs"><span class="hljs-variable">cse</span> := <span class="hljs-function"><span class="hljs-title">json_parse</span>(<span class="hljs-variable">features</span>)</span>
<span class="hljs-variable">expr</span> := <span class="hljs-function"><span class="hljs-title">TRY_CAST</span>(<span class="hljs-variable">cse</span>)</span>
<span class="hljs-variable">expr_0</span> := <span class="hljs-function"><span class="hljs-title">TRY_CAST</span>(<span class="hljs-variable">cse</span>)</span>
...
expr_4 := <span class="hljs-function"><span class="hljs-title">TRY_CAST</span>(<span class="hljs-variable">cse</span>)</span>
</code></pre>
<p>Since all assignments depend on this CSE, we will wrap them in a single <code>PageProjection</code> class. We generate a function for cse that computes its value on first invocation and stores it, and on later invocation will just return the result directly.</p>
<p><img src="/img/blog/2021-11-22-common-sub-expression-optimization/page-function-compiler.png" alt="PageFunctionCompiler"></p>
<p>In this way, the expensive <code>json_parse</code> will only need to be executed once.</p>
<p>Let’s look at another example to get a better understanding of what counts as CSEs. In the following query:</p>
<pre><code class="hljs">SELECT
    x + y + z,                        -- exp0
    x + y * z,                        -- exp1
    (x + y + z) * <span class="hljs-number">2</span>,                  -- exp2
    <span class="hljs-keyword">cast</span>(x + y + z as VARCHAR),       -- exp3
    (x + y + z) * <span class="hljs-number">2</span> * z               -- exp4
FROM 
    (VALUES (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) t(x, y, z);
</code></pre>
<p>There are 5 assignments in the projection, with 2 CSEs: <code>x + y + z</code> and <code>(x + y + z) * 2</code> (<code>x + y</code> is also a CSE but all expressions using this also uses <code>x + y + z</code> so we do not generate a separate function for it). We can rewrite this projection into:</p>
<pre><code class="hljs"><span class="hljs-string">cse1 :</span>= x + y + z
<span class="hljs-string">cse2 :</span>= cse1 * <span class="hljs-number">2</span>
<span class="hljs-string">expr0 :</span>= cse1
<span class="hljs-string">expr1 :</span>= x + y * z
<span class="hljs-string">expr2 :</span>= cse2
<span class="hljs-string">expr3 :</span>= CAST(cse1 <span class="hljs-keyword">as</span> VARCHAR)
<span class="hljs-string">expr4 :</span>= cse2 * z
</code></pre>
<p>From the rewritten assignments, we can see that expr1 does not share any CSEs with other expressions, and the rest do. We will generate 2 <code>PageProjection</code> classes, one for expr1, another one for the rest of the assignments.</p>
<h3><a class="anchor" aria-hidden="true" id="performance-benefit"></a><a href="#performance-benefit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Performance benefit</h3>
<p>Microbenchmark (<code>CommonSubExpessionBenchmark</code>) has shown that even for simple expressions like <code>x + y</code>, there could be a 10% performance improvement. For queries using complex expressions like <code>JSON_PARSE</code>, we’ve seen 3x performance improvements in production.</p>
<p><img src="/img/blog/2021-11-22-common-sub-expression-optimization/benchmark.png" alt="Benchmark"></p>
<h2><a class="anchor" aria-hidden="true" id="how-to-use-it"></a><a href="#how-to-use-it" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How to use it?</h2>
<p>This optimization was first introduced in Presto release 0.235. There were subsequent improvements and bug fixes in the releases after that, but it is considered stable since release 0.245. The optimization is on by default. You can turn it off by setting session property <code>SET SESSION optimize_common_sub_expressions = false</code> to see the performance difference.</p>
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/blog/">Recent Posts</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#the-problem">The problem</a></li><li><a href="#common-sub-expression-optimization">Common sub-expression optimization</a><ul class="toc-headings"><li><a href="#how-does-it-work">How does it work?</a></li><li><a href="#performance-benefit">Performance benefit</a></li></ul></li><li><a href="#how-to-use-it">How to use it?</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © The Presto Foundation.<br/>All rights reserved. Presto is a registered trademark of LF Projects, LLC. <br/>Please see our<a href="https://lfprojects.org/policies/trademark-policy/">Trademark Policy</a> for more information.<br/><a href="https://lfprojects.org/policies/privacy-policy/">Privacy Policy</a> |<a href="https://lfprojects.org/policies/terms-of-use/">Terms of Use</a>.</section></footer></div></body></html>